{
    "ACL_maxflow":{
		"prefix": "maxflow",
		"body":["from collections import deque",
				"class mf_graph:",
				"\tn=1",
				"\tg=[[] for i in range(1)]",
				"\tpos=[]",
				"\tdef __init__(self,N):",
				"\t\tself.n=N",
				"\t\tself.g=[[] for i in range(N)]",
				"\tdef add_edge(self,From,To,cap):",
				"\t\tassert 0<=From and From<self.n",
				"\t\tassert 0<=To and To<self.n",
				"\t\tassert 0<=cap",
				"\t\tm=len(self.pos)",
				"\t\tself.pos.append((From,len(self.g[From])))",
				"\t\tself.g[From].append({\"to\":To,\"rev\":len(self.g[To]),\"cap\":cap})",
				"\t\tself.g[To].append({\"to\":From,\"rev\":len(self.g[From])-1,\"cap\":0})",
				"\t\treturn m",
				"\tdef get_edge(self,i):",
				"\t\tm=len(self.pos)",
				"\t\tassert 0<=i and i<m",
				"\t\t_e=self.g[self.pos[i][0]][self.pos[i][1]]",
				"\t\t_re=self.g[_e[\"to\"]][_e[\"rev\"]]",
				"\t\treturn {\"from\":self.pos[i][0],",
				"\t\t\t\t\"to\":_e[\"to\"],",
				"\t\t\t\t\"cap\":_e[\"cap\"]+_re[\"cap\"],",
				"\t\t\t\t\"flow\":_re[\"cap\"]}",
				"\tdef edges(self):",
				"\t\tm=len(self.pos)",
				"\t\tresult=[]",
				"\t\tfor i in range(m):",
				"\t\t\tresult.append(self.get_edge(i))",
				"\t\treturn result",
				"\tdef change_edge(self,i,new_cap,new_flow):",
				"\t\tm=len(self.pos)",
				"\t\tassert 0<=i and i<m",
				"\t\tassert 0<=new_flow and new_flow<=new_cap",
				"\t\t_e=self.g[self.pos[i][0]][self.pos[i][1]]",
				"\t\t_re=self.g[_e[\"to\"]][_e[\"rev\"]]",
				"\t\t_e[\"cap\"]=new_cap-new_flow",
				"\t\t_re[\"cap\"]=new_flow",
				"\tdef flow(self,s,t,flow_limit=(2**31)-1):",
				"\t\tassert 0<=s and s<self.n",
				"\t\tassert 0<=t and t<self.n",
				"\t\tlevel=[0 for i in range(self.n)]",
				"\t\tIter=[0 for i in range(self.n)]",
				"\t\tque=deque([])",
				"\t\tdef bfs():",
				"\t\t\tfor i in range(self.n):",
				"\t\t\t\tlevel[i]=-1",
				"\t\t\tlevel[s]=0",
				"\t\t\tque=deque([])",
				"\t\t\tque.append(s)",
				"\t\t\twhile(len(que)>0):",
				"\t\t\t\tv=que.popleft()",
				"\t\t\t\tfor e in self.g[v]:",
				"\t\t\t\t\tif e[\"cap\"]==0 or level[e[\"to\"]]>=0:continue",
				"\t\t\t\t\tlevel[e[\"to\"]]=level[v]+1",
				"\t\t\t\t\tif e[\"to\"]==t:return",
				"\t\t\t\t\tque.append(e[\"to\"])",
				"\t\tdef dfs(func,v,up):",
				"\t\t\tif (v==s):return up",
				"\t\t\tres=0",
				"\t\t\tlevel_v=level[v]",
				"\t\t\tfor i in range(Iter[v],len(self.g[v])):",
				"\t\t\t\te=self.g[v][i]",
				"\t\t\t\tif (level_v<=level[e[\"to\"]] or self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]==0):continue",
				"\t\t\t\td=func(func,e[\"to\"],min(up-res,self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]))",
				"\t\t\t\tif d<=0:continue",
				"\t\t\t\tself.g[v][i][\"cap\"]+=d",
				"\t\t\t\tself.g[e[\"to\"]][e[\"rev\"]][\"cap\"]-=d",
				"\t\t\t\tres+=d",
				"\t\t\t\tif res==up:break",
				"\t\t\treturn res",
				"\t\tflow=0",
				"\t\twhile(flow<flow_limit):",
				"\t\t\tbfs()",
				"\t\t\tif level[t]==-1:",
				"\t\t\t\tbreak",
				"\t\t\tfor i in range(self.n):",
				"\t\t\t\tIter[i]=0",
				"\t\t\twhile(flow<flow_limit):",
				"\t\t\t\tf=dfs(dfs,t,flow_limit-flow)",
				"\t\t\t\tif not(f):break",
				"\t\t\t\tflow+=f",
				"\t\treturn flow",
				"\tdef min_cut(self,s):",
				"\t\tvisited=[False for i in range(self.n)]",
				"\t\tque=deque([])",
				"\t\tque.append(s)",
				"\t\twhile(len(que)>0):",
				"\t\t\tp=que.popleft()",
				"\t\t\tvisited[p]=True",
				"\t\t\tfor e in self.g[p]:",
				"\t\t\t\tif e[\"cap\"] and not(visited[e[\"to\"]]):",
				"\t\t\t\t\tvisited[e[\"to\"]]=True",
				"\t\t\t\t\tque.append(e[\"to\"])",
				"\t\treturn visited",],
		"description": "ACL_maxflow"
	},

    "ACL_lazy_segtree":{//遅延セグ木
		//書き方の例↓
		//https://atcoder.jp/contests/typical90/submissions/22515868
		"prefix": "lazysegtree",
		"body":["class LazySegtree():",
				"\tdef update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])",
				"\tdef all_apply(self,k,f):",
				"\t\tself.d[k]=self.mapping(f,self.d[k])",
				"\t\tif (k<self.size):self.lz[k]=self.composition(f,self.lz[k])",
				"\tdef push(self,k):",
				"\t\tself.all_apply(2*k,self.lz[k])",
				"\t\tself.all_apply(2*k+1,self.lz[k])",
				"\t\tself.lz[k]=self.identity",
				"\tdef __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):",
				"\t\tself.n=len(V)",
				"\t\tself.log=(self.n-1).bit_length()",
				"\t\tself.size=1<<self.log",
				"\t\tself.d=[E for i in range(2*self.size)]",
				"\t\tself.lz=[ID for i in range(self.size)]",
				"\t\tself.e=E",
				"\t\tself.op=OP",
				"\t\tself.mapping=MAPPING",
				"\t\tself.composition=COMPOSITION",
				"\t\tself.identity=ID",
				"\t\tfor i in range(self.n):self.d[self.size+i]=V[i]",
				"\t\tfor i in range(self.size-1,0,-1):self.update(i)",
				"\tdef set(self,p,x):",
				"\t\tassert 0<=p and p<self.n",
				"\t\tp+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(p>>i)",
				"\t\tself.d[p]=x",
				"\t\tfor i in range(1,self.log+1):self.update(p>>i)",
				"\tdef get(self,p):",
				"\t\tassert 0<=p and p<self.n",
				"\t\tp+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(p>>i)",
				"\t\treturn self.d[p]",
				"\tdef prod(self,l,r):",
				"\t\tassert 0<=l and l<=r and r<=self.n",
				"\t\tif l==r:return self.e",
				"\t\tl+=self.size",
				"\t\tr+=self.size",
				"\t\tfor i in range(self.log,0,-1):",
				"\t\t\tif (((l>>i)<<i)!=l):self.push(l>>i)",
				"\t\t\tif (((r>>i)<<i)!=r):self.push(r>>i)",
				"\t\tsml,smr=self.e,self.e",
				"\t\twhile(l<r):",
				"\t\t\tif l&1:",
				"\t\t\t\tsml=self.op(sml,self.d[l])",
				"\t\t\t\tl+=1",
				"\t\t\tif r&1:",
				"\t\t\t\tr-=1",
				"\t\t\t\tsmr=self.op(self.d[r],smr)",
				"\t\t\tl>>=1",
				"\t\t\tr>>=1",
				"\t\treturn self.op(sml,smr)",
				"\tdef all_prod(self):return self.d[1]",
				"\tdef apply_point(self,p,f):",
				"\t\tassert 0<=p and p<self.n",
				"\t\tp+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(p>>i)",
				"\t\tself.d[p]=self.mapping(f,self.d[p])",
				"\t\tfor i in range(1,self.log+1):self.update(p>>i)",
				"\tdef apply(self,l,r,f):",
				"\t\tassert 0<=l and l<=r and r<=self.n",
				"\t\tif l==r:return",
				"\t\tl+=self.size",
				"\t\tr+=self.size",
				"\t\tfor i in range(self.log,0,-1):",
				"\t\t\tif (((l>>i)<<i)!=l):self.push(l>>i)",
				"\t\t\tif (((r>>i)<<i)!=r):self.push((r-1)>>i)",
				"\t\tl2,r2=l,r",
				"\t\twhile(l<r):",
				"\t\t\tif (l&1):",
				"\t\t\t\tself.all_apply(l,f)",
				"\t\t\t\tl+=1",
				"\t\t\tif (r&1):",
				"\t\t\t\tr-=1",
				"\t\t\t\tself.all_apply(r,f)",
				"\t\t\tl>>=1",
				"\t\t\tr>>=1",
				"\t\tl,r=l2,r2",
				"\t\tfor i in range(1,self.log+1):",
				"\t\t\tif (((l>>i)<<i)!=l):self.update(l>>i)",
				"\t\t\tif (((r>>i)<<i)!=r):self.update((r-1)>>i)",
				"\tdef max_right(self,l,g):",
				"\t\tassert 0<=l and l<=self.n",
				"\t\tassert g(self.e)",
				"\t\tif l==self.n:return self.n",
				"\t\tl+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(l>>i)",
				"\t\tsm=self.e",
				"\t\twhile(1):",
				"\t\t\twhile(i%2==0):l>>=1",
				"\t\t\tif not(g(self.op(sm,self.d[l]))):",
				"\t\t\t\twhile(l<self.size):",
				"\t\t\t\t\tself.push(l)",
				"\t\t\t\t\tl=(2*l)",
				"\t\t\t\t\tif (g(self.op(sm,self.d[l]))):",
				"\t\t\t\t\t\tsm=self.op(sm,self.d[l])",
				"\t\t\t\t\t\tl+=1",
				"\t\t\t\treturn l-self.size",
				"\t\t\tsm=self.op(sm,self.d[l])",
				"\t\t\tl+=1",
				"\t\t\tif (l&-l)==l:break",
				"\t\treturn self.n",
				"\tdef min_left(self,r,g):",
				"\t\tassert (0<=r and r<=self.n)",
				"\t\tassert g(self.e)",
				"\t\tif r==0:return 0",
				"\t\tr+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push((r-1)>>i)",
				"\t\tsm=self.e",
				"\t\twhile(1):",
				"\t\t\tr-=1",
				"\t\t\twhile(r>1 and (r%2)):r>>=1",
				"\t\t\tif not(g(self.op(self.d[r],sm))):",
				"\t\t\t\twhile(r<self.size):",
				"\t\t\t\t\tself.push(r)",
				"\t\t\t\t\tr=(2*r+1)",
				"\t\t\t\t\tif g(self.op(self.d[r],sm)):",
				"\t\t\t\t\t\tsm=self.op(self.d[r],sm)",
				"\t\t\t\t\t\tr-=1",
				"\t\t\t\treturn r+1-self.size",
				"\t\t\tsm=self.op(self.d[r],sm)",
				"\t\t\tif (r&-r)==r:break",
				"\t\treturn 0",],
		"description": "ACL_lazy_segtree",
	},

	"ACL_fenwick_tree":{
		"prefix": "fenwicktree",
		"body":["class FenwickTree():",
				"\tn=1",
				"\tdata=[0 for i in range(n)]",
				"\tdef __init__(self,N):",
				"\t\tself.n=N",
				"\t\tself.data=[0 for i in range(N)]",
				"\tdef add(self,p,x):",
				"\t\tassert 0<=p<self.n,'0<=p<n,p={0},n={1}'.format(p,self.n)",
				"\t\tp+=1",
				"\t\twhile(p<=self.n):",
				"\t\t\tself.data[p-1]+=x",
				"\t\t\tp+=p& -p",
				"\tdef sum(self,l,r):",
				"\t\tassert (0<=l and l<=r and r<=self.n),'0<=l<=r<=n,l={0},r={1},n={2}'.format(l,r,self.n)",
				"\t\treturn self.sum0(r)-self.sum0(l)",
				"\tdef sum0(self,r):",
				"\t\ts=0",
				"\t\twhile(r>0):",
				"\t\t\ts+=self.data[r-1]",
				"\t\t\tr-=r&-r",
				"\t\treturn s",],
		"description": "fenwicktree"
	},
}