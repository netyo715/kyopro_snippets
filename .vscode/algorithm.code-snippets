{
	"factorization":{
		"prefix": "soinsuubunkai",
		"body":["def factorization(n):",
				"\tarr = []",
				"\ttemp = n",
				"\tfor i in range(2, int(-(-n**0.5//1))+1):",
				"\t\tif temp%i==0:",
				"\t\t\tcnt=0",
				"\t\t\twhile temp%i==0:",
				"\t\t\t\tcnt+=1",
				"\t\t\t\ttemp //= i",
				"\t\t\tarr.append([i, cnt])",
				"\tif temp!=1:",
				"\t\tarr.append([temp, 1])",
				"\tif arr==[]:",
				"\t\tarr.append([n, 1])",
				"\treturn arr"],
		"description": "素因数分解"
	},

	"combination":{
		"prefix": "ncr",
		"body":["def cmb(n, r, mod):",
				"\tif (r < 0) or (n < r):",
				"\t\treturn 0",
				"\tr = min(r, n - r)",
				"\treturn fact[n] * factinv[r] * factinv[n-r] % mod",
				"",
				"MOD = 10**9+7",
				"N = 10**6  # N は必要分だけ用意する",
				"fact = [1, 1]  # fact[n] = (n! mod mod)",
				"factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod mod)",
				"inv = [0, 1]  # factinv 計算用",
				" ",
				"for i in range(2, N + 1):",
				"\tfact.append((fact[-1] * i) % mod)",
				"\tinv.append((-inv[mod % i] * (mod // i)) % mod)",
				"\tfactinv.append((factinv[-1] * inv[-1]) % mod)"],
		"description": "nCr n個からr個選ぶ組み合わせmod mod"
	},

	"cumulative sum":{
		"prefix": "zalgo",
		"body":["def z(s):",
				"\tn = len(s)",
				"\tret = [0]*n",
				"\tret[0] = n",
				"\ti = 1",
				"\tj = 0",
				"\twhile i < n:",
				"\t\twhile i+j < n and s[j] == s[i+j]:",
				"\t\t\tj += 1",
				"\t\tret[i] = j",
				"\t\tif j == 0:",
				"\t\t\ti += 1",
				"\t\t\tcontinue",
				"\t\tk = 1",
				"\t\twhile i+k < n and k+ret[k] < j:",
				"\t\t\tret[i+k] = ret[k]",
				"\t\t\tk += 1",
				"\t\ti += k",
				"\t\tj -= k",
				"\treturn ret"],
		"description": "z-algorithm"
	},

	"union find":{
		"prefix": "unionfind",
		"body":["class UnionFind():",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.parents = [-1] * n",		
				"",
				"\tdef find(self, x):",
				"\t\tif self.parents[x] < 0:",
				"\t\t\treturn x",
				"\t\telse:",
				"\t\t\tself.parents[x] = self.find(self.parents[x])",
				"\t\t\treturn self.parents[x]",
				"",
				"\tdef union(self, x, y):",
				"\t\tx = self.find(x)",
				"\t\ty = self.find(y)",
				"\t\tif x == y:",
				"\t\t\treturn",
				"\t\tif self.parents[x] > self.parents[y]:",
				"\t\t\tx, y = y, x",
				"\t\tself.parents[x] += self.parents[y]",
				"\t\tself.parents[y] = x",
				"",
				"\tdef size(self, x):",
				"\t\treturn -self.parents[self.find(x)]",
				"",
				"\tdef same(self, x, y):",
				"\t\treturn self.find(x) == self.find(y)",
				"",
				"\tdef members(self, x):",
				"\t\troot = self.find(x)",
				"\t\treturn [i for i in range(self.n) if self.find(i) == root]",
				"",
				"\tdef roots(self):",
				"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
				"",
				"\tdef group_count(self):",
				"\t\treturn len(self.roots())",
				"",
				"\tdef all_group_members(self):",
				"\t\treturn {r: self.members(r) for r in self.roots()}",
				"",
				"\tdef __str__(self):",
				"\t\treturn '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())"],
		"description": "unionfind"
	},

	"meguru_bisect":{
		"prefix": "megurubisect",
		"body":["def is_ok(arg):",
				"\t# 条件を満たすかどうか？問題ごとに定義",
				"\tpass",
				"",
				"",
				"def meguru_bisect(ng, ok):",
				"\t'''",
				"\t初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す",
				"\tまずis_okを定義すべし",
				"\tng ok は  とり得る最小の値-1 とり得る最大の値+1",
				"\t最大最小が逆の場合はよしなにひっくり返す",
				"\t'''",
				"\twhile (abs(ok - ng) > 1):",
				"\t\tmid = (ok + ng) // 2",
				"\t\tif is_ok(mid):",
				"\t\t\tok = mid",
				"\t\telse:",
				"\t\t\tng = mid",
				"\treturn ok"],
		"description": "めぐる式二分探索"
	},

	"fenwicktree":{
		"prefix": "fenwicktree",
		"body":["class BIT:",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.data = [0]*(n+1)",
				"\t\tself.el = [0]*(n+1)",
				"",
				"\tdef sum(self, i):",
				"\t\ts = 0",
				"\t\twhile i > 0:",
				"\t\t\ts += self.data[i]",
				"\t\t\ti -= i & -i",
				"\t\treturn s",
				"",
				"\tdef add(self, i, x):",
				"\t\tself.el[i] += x",
				"\t\twhile i <= self.n:",
				"\t\t\tself.data[i] += x",
				"\t\t\ti += i & -i",
				"\t\t\t",
				"\tdef get(self, i, j=None):",
				"\t\tif j is None:",
				"\t\t\treturn self.el[i]",
				"\t\treturn self.sum(j) - self.sum(i)"],
		"description": "fenwick tree (BIT)"
	},

	"segment tree":{
		"prefix": "segtree",
		"body":["class SegTree:",
				"\tdef __init__(self, N, A, ide_ele):",
				"\t\tself.N = N",
				"\t\t#####単位元######",
				"\t\t#最小値のセグ木 → +inf",
				"\t\t#和のセグ木 → 0",
				"\t\t#積のセグ木 → 1",
				"\t\t#gcdのセグ木 → 0",
				"\t\tself.ide_ele = ide_ele",
				"",
				"\t\t#num:n以上の最小の2のべき乗",
				"\t\tself.num =2**(self.N-1).bit_length()",
				"\t\tself.seg=[self.ide_ele]*2*self.num",
				"",
				"\t\tself.init(A)",
				"",
				"\t#####segfunc######",
				"\tdef segfunc(self, x,y):",
				"\t\treturn ",
				"",
				"\tdef init(self, init_val):",
				"\t\t#set_val",
				"\t\tfor i in range(self.N):",
				"\t\t\tself.seg[i+self.num-1]=init_val[i]       ",
				"\t\t#built",
				"\t\tfor i in range(self.num-2,-1,-1) :",
				"\t\t\tself.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) ",
				"\t\t",
				"\tdef update(self, k,x):",
				"\t\tk += self.num-1",
				"\t\tself.seg[k] = x",
				"\t\twhile k:",
				"\t\t\tk = (k-1)//2",
				"\t\t\tself.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])",
				"\t\t",
				"\tdef query(self, p,q):",
				"\t\tif q<=p:",
				"\t\t\treturn self.ide_ele",
				"\t\tp += self.num-1",
				"\t\tq += self.num-2",
				"\t\tres=self.ide_ele",
				"\t\twhile q-p>1:",
				"\t\t\tif p&1 == 0:",
				"\t\t\t\tres = self.segfunc(res,self.seg[p])",
				"\t\t\tif q&1 == 1:",
				"\t\t\t\tres = self.segfunc(res,self.seg[q])",
				"\t\t\t\tq -= 1",
				"\t\t\tp = p//2",
				"\t\t\tq = (q-1)//2",
				"\t\tif p == q:",
				"\t\t\tres = self.segfunc(res,self.seg[p])",
				"\t\telse:",
				"\t\t\tres = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])",
				"\t\treturn res"],
		"description": "セグメント木"
	},

	"modinv": {
		"prefix": "gyakugen",
		"body":["def xgcd(a, b):",
				"\tx0, y0, x1, y1 = 1, 0, 0, 1",
				"\twhile b != 0:",
				"\t\tq, a, b = a // b, b, a % b",
				"\t\tx0, x1 = x1, x0 - q * x1",
				"\t\ty0, y1 = y1, y0 - q * y1",
				"\treturn a, x0, y0",
				"",
				"def modinv(a, m):",
				"\tg, x, y = xgcd(a, m)",
				"\tif g != 1:",
				"\t\traise Exception('modular inverse does not exist')",
				"\telse:",
				"\t\treturn x % m"],
		"description": "aの逆元を求める"
	},

	"最小包含円": {
		"prefix": "saisyouhouganen",
		"body":["from copy import copy",
				"from itertools import combinations",
				"from random import sample",
				"",
				"class circle:",
				"\tdef __init__(self, pts):",
				"\t\tassert(0 <= len(pts) and len(pts) <= 3)",
				"\t\tself.__pts = copy(pts)",
				"\t\tif len(pts) == 0:",
				"\t\t\tself.__cx, self.__cy, self.__r = float('inf'), float('inf'), 0",
				"\t\telif len(pts) == 1:",
				"\t\t\tself.__cx, self.__cy, self.__r = *pts[0], 0",
				"\t\telif len(pts) == 2:",
				"\t\t\tself.__cx, self.__cy, self.__r = self.__c2()",
				"\t\telse:",
				"\t\t\tself.__cx, self.__cy, self.__r = self.__c3()",
				"",
				"\tdef __c2(self):",
				"\t\tassert(len(self.__pts) == 2)",
				"\t\t(x0, y0), (x1, y1) = self.__pts",
				"\t\treturn ((x0+x1)/2, (y0+y1)/2,",
				"\t\t\t\t0.5*((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1))**0.5)",
				"",
				"\tdef __c3(self):",
				"\t\tassert(len(self.__pts) == 3)",
				"\t\treturn self.__o3() if self.__obtuse() else self.__a3()",
				"",
				"\tdef __o3(self):",
				"\t\tp, q = max(((xi-xj)**2 + (yi-yj)**2, ((xi, yi), (xj, yj)))",
				"\t\t\t\t   for (xi, yi), (xj, yj) in combinations(self.__pts, 2))[1]",
				"\t\tself.__pts = [p, q]",
				"\t\treturn self.__c2()",
				"",
				"\tdef __obtuse(self):",
				"\t\t(x0, y0), (x1, y1), (x2, y2) = self.__pts",
				"\t\ta = (x0-x1)**2 + (y0-y1)**2",
				"\t\tb = (x1-x2)**2 + (y1-y2)**2",
				"\t\tc = (x2-x0)**2 + (y2-y0)**2",
				"\t\treturn a > b+c or b > c+a or c > a+b",
				"",
				"\tdef __a3(self):",
				"\t\t(x0, y0), (x1, y1), (x2, y2) = self.__pts",
				"",
				"\t\tx01, x02 = x0 - x1, x0 - x2",
				"\t\ty01, y02 = y0 - y1, y0 - y2",
				"",
				"\t\ty20, y10 = y2 - y0, y1 - y0",
				"\t\tx20, x10 = x2 - x0, x1 - x0",
				"",
				"\t\tsx02, sy02 = x0*x0 - x2*x2, y0*y0 - y2*y2",
				"\t\tsx10, sy10 = x1*x1 - x0*x0, y1*y1 - y0*y0",
				"",
				"\t\tf = (sx02*x01+sy02*x01 + sx10*x02+sy10*x02) / (2*(y20*x01 - y10*x02))",
				"\t\tg = (sx02*y01+sy02*y01 + sx10*y02+sy10*y02) / (2*(x20*y01 - x10*y02))",
				"\t\tc = -x0*x0 - y0*y0 - 2*g*x0 - 2*f*y0",
				"",
				"\t\treturn (-g, -f, (f*f + g*g - c)**0.5)",
				"",
				"\tdef contains(self, x, y):",
				"\t\treturn ((x-self.__cx)**2 + (y-self.__cy)**2)**0.5 <= self.__r + 1e-9",
				"",
				"\tdef pts(self):",
				"\t\treturn set(self.__pts)",
				"",
				"\t@property",
				"\tdef center(self):",
				"\t\treturn (self.__cx, self.__cy)",
				"",
				"\t@property",
				"\tdef radius(self):",
				"\t\treturn self.__r",
				"",
				"",
				"def welzl(p, r=set()):",
				"\tif len(p) == 0 or len(r) == 3:",
				"\t\treturn circle(list(r))",
				"\tq = sample(p, 1)[0]   # randomly and uniformly",
				"\td = welzl(set(p) - {q}, r)",
				"\tif d.contains(*q):",
				"\t\treturn d",
				"\treturn welzl(set(p) - {q}, r | {q})",
				"",
				"",
				"def msw(pts):",
				"\tif len(pts) <= 3:",
				"\t\treturn circle(pts)",
				"\treturn _msw(set(pts), set(sample(pts, 3)))",
				"",
				"",
				"def _msw(p, r):",
				"\tif len(p) == 0:",
				"\t\treturn circle(list(r))",
				"\tq = sample(p, 1)[0]",
				"\td = _msw(p - {q}, r)",
				"\tif d.contains(*q):",
				"\t\treturn d",
				"\tx = (r | {q}) - welzl(r | {q}).pts()",
				"\treturn _msw((p - {q}) | x, (r | {q}) - x)",
				"",
				"#en = [(0, 0), (1, 2)]",
				"#msw(en)"],
		"description": "最小包含円"
	}
}