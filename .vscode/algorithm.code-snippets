{
	"factorization":{//与えられた整数を素因数分解する
		"prefix": "soinsuubunkai",
		"body":["def factorization(n):",
				"\tarr = []",
				"\ttemp = n",
				"\tfor i in range(2, int(-(-n**0.5//1))+1):",
				"\t\tif temp%i==0:",
				"\t\t\tcnt=0",
				"\t\t\twhile temp%i==0:",
				"\t\t\t\tcnt+=1",
				"\t\t\t\ttemp //= i",
				"\t\t\tarr.append([i, cnt])",
				"\tif temp!=1:",
				"\t\tarr.append([temp, 1])",
				"\tif arr==[]:",
				"\t\tarr.append([n, 1])",
				"\treturn arr"],
		"description": "与えられた整数を素因数分解する"
	},

	"combination":{//前計算をしてnCrをmodで割ったあまりを求める
		"prefix": "ncr",
		"body":["cmbMOD = 10**9+7",
				"cmbN = 10**6",
				"cmbfact = [1, 1]  # fact[n] = (n! mod MOD)",
				"cmbfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod MOD)",
				"cmbinv = [0, 1]  # factinv 計算用",
				"",
				"for i in range(2, cmbN + 1):",
				"\tcmbfact.append((cmbfact[-1] * i) % cmbMOD)",
				"\tcmbinv.append((-cmbinv[cmbMOD % i] * (cmbMOD // i)) % cmbMOD)",
				"\tcmbfactinv.append((cmbfactinv[-1] * cmbinv[-1]) % cmbMOD)",
				"",
				"def cmb(n, r):",
				"\tif (r < 0) or (n < r):",
				"\t\treturn 0",
				"\tr = min(r, n - r)",
				"\treturn cmbfact[n] * cmbfactinv[r] * cmbfactinv[n-r] % cmbMOD"],
		"description": "nCr n個からr個選ぶ組み合わせmod MOD"
	},

	"cumulative sum":{//zアルゴリズム SとS[i:]の共通接頭辞の長さを全てのiについて求める
		"prefix": "zalgo",
		"body":["def z(s):",
				"\tn = len(s)",
				"\tret = [0]*n",
				"\tret[0] = n",
				"\ti = 1",
				"\tj = 0",
				"\twhile i < n:",
				"\t\twhile i+j < n and s[j] == s[i+j]:",
				"\t\t\tj += 1",
				"\t\tret[i] = j",
				"\t\tif j == 0:",
				"\t\t\ti += 1",
				"\t\t\tcontinue",
				"\t\tk = 1",
				"\t\twhile i+k < n and k+ret[k] < j:",
				"\t\t\tret[i+k] = ret[k]",
				"\t\t\tk += 1",
				"\t\ti += k",
				"\t\tj -= k",
				"\treturn ret"],
		"description": "z-algorithm"
	},

	"union find":{//unionfind木
		"prefix": "unionfind",
		"body":["class UnionFind():",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.parents = [-1] * n",		
				"",
				"\tdef find(self, x):",
				"\t\tif self.parents[x] < 0:",
				"\t\t\treturn x",
				"\t\telse:",
				"\t\t\tself.parents[x] = self.find(self.parents[x])",
				"\t\t\treturn self.parents[x]",
				"",
				"\tdef union(self, x, y):",
				"\t\tx = self.find(x)",
				"\t\ty = self.find(y)",
				"\t\tif x == y:",
				"\t\t\treturn",
				"\t\tif self.parents[x] > self.parents[y]:",
				"\t\t\tx, y = y, x",
				"\t\tself.parents[x] += self.parents[y]",
				"\t\tself.parents[y] = x",
				"",
				"\tdef size(self, x):",
				"\t\treturn -self.parents[self.find(x)]",
				"",
				"\tdef same(self, x, y):",
				"\t\treturn self.find(x) == self.find(y)",
				"",
				"\tdef members(self, x):",
				"\t\troot = self.find(x)",
				"\t\treturn [i for i in range(self.n) if self.find(i) == root]",
				"",
				"\tdef roots(self):",
				"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
				"",
				"\tdef group_count(self):",
				"\t\treturn len(self.roots())",
				"",
				"\tdef all_group_members(self):",
				"\t\treturn {r: self.members(r) for r in self.roots()}",
				"",
				"\tdef __str__(self):",
				"\t\treturn '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())"],
		"description": "unionfind"
	},

	"meguru_bisect":{//二分探索
		"prefix": "megurubisect",
		"body":["def is_ok(arg):",
				"\tpass",
				"",
				"",
				"def meguru_bisect(ng, ok):",
				"\twhile (abs(ok - ng) > 1):",
				"\t\tmid = (ok + ng) // 2",
				"\t\tif is_ok(mid):",
				"\t\t\tok = mid",
				"\t\telse:",
				"\t\t\tng = mid",
				"\treturn ok"],
		"description": "めぐる式二分探索"
	},

	"fenwicktree":{//fenwicktree/BIT 区間の総和がとれるやつ
		"prefix": "fenwicktree",
		"body":["class BIT:",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.data = [0]*(n+1)",
				"\t\tself.el = [0]*(n+1)",
				"",
				"\tdef sum(self, i):",
				"\t\ts = 0",
				"\t\twhile i > 0:",
				"\t\t\ts += self.data[i]",
				"\t\t\ti -= i & -i",
				"\t\treturn s",
				"",
				"\tdef add(self, i, x):",
				"\t\tself.el[i] += x",
				"\t\twhile i <= self.n:",
				"\t\t\tself.data[i] += x",
				"\t\t\ti += i & -i",
				"\t\t\t",
				"\tdef get(self, i, j=None):",
				"\t\tif j is None:",
				"\t\t\treturn self.el[i]",
				"\t\treturn self.sum(j) - self.sum(i)"],
		"description": "fenwick tree (BIT)"
	},

	"segment tree":{//セグ木
		"prefix": "segtree",
		"body":["class SegTree:",
				"\tdef __init__(self, N, A, ide_ele):",
				"\t\tself.N = N",
				"\t\t#####単位元######",
				"\t\t#最小値のセグ木 → +inf",
				"\t\t#和のセグ木 → 0",
				"\t\t#積のセグ木 → 1",
				"\t\t#gcdのセグ木 → 0",
				"\t\tself.ide_ele = ide_ele",
				"",
				"\t\t#num:n以上の最小の2のべき乗",
				"\t\tself.num =2**(self.N-1).bit_length()",
				"\t\tself.seg=[self.ide_ele]*2*self.num",
				"",
				"\t\tself.init(A)",
				"",
				"\t#####segfunc######",
				"\tdef segfunc(self, x,y):",
				"\t\treturn ",
				"",
				"\tdef init(self, init_val):",
				"\t\t#set_val",
				"\t\tfor i in range(self.N):",
				"\t\t\tself.seg[i+self.num-1]=init_val[i]       ",
				"\t\t#built",
				"\t\tfor i in range(self.num-2,-1,-1) :",
				"\t\t\tself.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) ",
				"\t\t",
				"\tdef update(self, k,x):",
				"\t\tk += self.num-1",
				"\t\tself.seg[k] = x",
				"\t\twhile k:",
				"\t\t\tk = (k-1)//2",
				"\t\t\tself.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])",
				"\t\t",
				"\tdef query(self, p,q):",
				"\t\tif q<=p:",
				"\t\t\treturn self.ide_ele",
				"\t\tp += self.num-1",
				"\t\tq += self.num-2",
				"\t\tres=self.ide_ele",
				"\t\twhile q-p>1:",
				"\t\t\tif p&1 == 0:",
				"\t\t\t\tres = self.segfunc(res,self.seg[p])",
				"\t\t\tif q&1 == 1:",
				"\t\t\t\tres = self.segfunc(res,self.seg[q])",
				"\t\t\t\tq -= 1",
				"\t\t\tp = p//2",
				"\t\t\tq = (q-1)//2",
				"\t\tif p == q:",
				"\t\t\tres = self.segfunc(res,self.seg[p])",
				"\t\telse:",
				"\t\t\tres = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])",
				"\t\treturn res"],
		"description": "セグメント木"
	},

	"ACL_lazy_segtree":{//遅延セグ木
		//書き方の例↓
		//https://atcoder.jp/contests/typical90/submissions/22515868
		"prefix": "lazysegtree",
		"body":["class LazySegtree():",
				"\tdef update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])",
				"\tdef all_apply(self,k,f):",
				"\t\tself.d[k]=self.mapping(f,self.d[k])",
				"\t\tif (k<self.size):self.lz[k]=self.composition(f,self.lz[k])",
				"\tdef push(self,k):",
				"\t\tself.all_apply(2*k,self.lz[k])",
				"\t\tself.all_apply(2*k+1,self.lz[k])",
				"\t\tself.lz[k]=self.identity",
				"\tdef __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):",
				"\t\tself.n=len(V)",
				"\t\tself.log=(self.n-1).bit_length()",
				"\t\tself.size=1<<self.log",
				"\t\tself.d=[E for i in range(2*self.size)]",
				"\t\tself.lz=[ID for i in range(self.size)]",
				"\t\tself.e=E",
				"\t\tself.op=OP",
				"\t\tself.mapping=MAPPING",
				"\t\tself.composition=COMPOSITION",
				"\t\tself.identity=ID",
				"\t\tfor i in range(self.n):self.d[self.size+i]=V[i]",
				"\t\tfor i in range(self.size-1,0,-1):self.update(i)",
				"\tdef set(self,p,x):",
				"\t\tassert 0<=p and p<self.n",
				"\t\tp+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(p>>i)",
				"\t\tself.d[p]=x",
				"\t\tfor i in range(1,self.log+1):self.update(p>>i)",
				"\tdef get(self,p):",
				"\t\tassert 0<=p and p<self.n",
				"\t\tp+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(p>>i)",
				"\t\treturn self.d[p]",
				"\tdef prod(self,l,r):",
				"\t\tassert 0<=l and l<=r and r<=self.n",
				"\t\tif l==r:return self.e",
				"\t\tl+=self.size",
				"\t\tr+=self.size",
				"\t\tfor i in range(self.log,0,-1):",
				"\t\t\tif (((l>>i)<<i)!=l):self.push(l>>i)",
				"\t\t\tif (((r>>i)<<i)!=r):self.push(r>>i)",
				"\t\tsml,smr=self.e,self.e",
				"\t\twhile(l<r):",
				"\t\t\tif l&1:",
				"\t\t\t\tsml=self.op(sml,self.d[l])",
				"\t\t\t\tl+=1",
				"\t\t\tif r&1:",
				"\t\t\t\tr-=1",
				"\t\t\t\tsmr=self.op(self.d[r],smr)",
				"\t\t\tl>>=1",
				"\t\t\tr>>=1",
				"\t\treturn self.op(sml,smr)",
				"\tdef all_prod(self):return self.d[1]",
				"\tdef apply_point(self,p,f):",
				"\t\tassert 0<=p and p<self.n",
				"\t\tp+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(p>>i)",
				"\t\tself.d[p]=self.mapping(f,self.d[p])",
				"\t\tfor i in range(1,self.log+1):self.update(p>>i)",
				"\tdef apply(self,l,r,f):",
				"\t\tassert 0<=l and l<=r and r<=self.n",
				"\t\tif l==r:return",
				"\t\tl+=self.size",
				"\t\tr+=self.size",
				"\t\tfor i in range(self.log,0,-1):",
				"\t\t\tif (((l>>i)<<i)!=l):self.push(l>>i)",
				"\t\t\tif (((r>>i)<<i)!=r):self.push((r-1)>>i)",
				"\t\tl2,r2=l,r",
				"\t\twhile(l<r):",
				"\t\t\tif (l&1):",
				"\t\t\t\tself.all_apply(l,f)",
				"\t\t\t\tl+=1",
				"\t\t\tif (r&1):",
				"\t\t\t\tr-=1",
				"\t\t\t\tself.all_apply(r,f)",
				"\t\t\tl>>=1",
				"\t\t\tr>>=1",
				"\t\tl,r=l2,r2",
				"\t\tfor i in range(1,self.log+1):",
				"\t\t\tif (((l>>i)<<i)!=l):self.update(l>>i)",
				"\t\t\tif (((r>>i)<<i)!=r):self.update((r-1)>>i)",
				"\tdef max_right(self,l,g):",
				"\t\tassert 0<=l and l<=self.n",
				"\t\tassert g(self.e)",
				"\t\tif l==self.n:return self.n",
				"\t\tl+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push(l>>i)",
				"\t\tsm=self.e",
				"\t\twhile(1):",
				"\t\t\twhile(i%2==0):l>>=1",
				"\t\t\tif not(g(self.op(sm,self.d[l]))):",
				"\t\t\t\twhile(l<self.size):",
				"\t\t\t\t\tself.push(l)",
				"\t\t\t\t\tl=(2*l)",
				"\t\t\t\t\tif (g(self.op(sm,self.d[l]))):",
				"\t\t\t\t\t\tsm=self.op(sm,self.d[l])",
				"\t\t\t\t\t\tl+=1",
				"\t\t\t\treturn l-self.size",
				"\t\t\tsm=self.op(sm,self.d[l])",
				"\t\t\tl+=1",
				"\t\t\tif (l&-l)==l:break",
				"\t\treturn self.n",
				"\tdef min_left(self,r,g):",
				"\t\tassert (0<=r and r<=self.n)",
				"\t\tassert g(self.e)",
				"\t\tif r==0:return 0",
				"\t\tr+=self.size",
				"\t\tfor i in range(self.log,0,-1):self.push((r-1)>>i)",
				"\t\tsm=self.e",
				"\t\twhile(1):",
				"\t\t\tr-=1",
				"\t\t\twhile(r>1 and (r%2)):r>>=1",
				"\t\t\tif not(g(self.op(self.d[r],sm))):",
				"\t\t\t\twhile(r<self.size):",
				"\t\t\t\t\tself.push(r)",
				"\t\t\t\t\tr=(2*r+1)",
				"\t\t\t\t\tif g(self.op(self.d[r],sm)):",
				"\t\t\t\t\t\tsm=self.op(self.d[r],sm)",
				"\t\t\t\t\t\tr-=1",
				"\t\t\t\treturn r+1-self.size",
				"\t\t\tsm=self.op(self.d[r],sm)",
				"\t\t\tif (r&-r)==r:break",
				"\t\treturn 0",],
		"description": "ACL_lazy_segtree",
	},
	
	"modinv": {//a mod m aの逆元を求める
		"prefix": "gyakugen",
		"body":["def xgcd(a, b):",
				"\tx0, y0, x1, y1 = 1, 0, 0, 1",
				"\twhile b != 0:",
				"\t\tq, a, b = a // b, b, a % b",
				"\t\tx0, x1 = x1, x0 - q * x1",
				"\t\ty0, y1 = y1, y0 - q * y1",
				"\treturn a, x0, y0",
				"",
				"def modinv(a, m):",
				"\tg, x, y = xgcd(a, m)",
				"\tif g != 1:",
				"\t\traise Exception('modular inverse does not exist')",
				"\telse:",
				"\t\treturn x % m"],
		"description": "aの逆元を求める"
	},

}