{
	"factorization":{
		"prefix": "soinsuubunkai",
		"body":["def factorization(n):",
				"\tarr = []",
				"\ttemp = n",
				"\tfor i in range(2, int(-(-n**0.5//1))+1):",
				"\t\tif temp%i==0:",
				"\t\t\tcnt=0",
				"\t\t\twhile temp%i==0:",
				"\t\t\t\tcnt+=1",
				"\t\t\t\ttemp //= i",
				"\t\t\tarr.append([i, cnt])",
				"\tif temp!=1:",
				"\t\tarr.append([temp, 1])",
				"\tif arr==[]:",
				"\t\tarr.append([n, 1])",
				"\treturn arr"],
		"description": "素因数分解"
	},

	"combination":{
		"prefix": "ncr",
		"body":["def cmb(n, r, p):",
			"\tif (r < 0) or (n < r):",
			"\t\treturn 0",
			"\tr = min(r, n-r)",
			"\tfact = [1, 1]",
			"\tfactinv = [1, 1]",
			"\tinv = [0, 1]",
			"\tfor i in range(2, n+1):",
			"\t\tfact.append((fact[-1] * i) % p)",
			"\t\tinv.append((-inv[p % i] * (p // i)) % p)",
			"\t\tfactinv.append((factinv[-1] * inv[-1]) % p)",
			"\treturn fact[n] * factinv[r] * factinv[n-r] % p"],
		"description": "nCr n個からr個選ぶ組み合わせmod p"
	},

	"cumulative sum":{
		"prefix": "ruisekiwa",
		"body":["def cumulative_sum(A):",
				"\tif not A:",
				"\t\treturn []",
				"\tB = [A[0]]",
				"\tfor a in A[1:]:",
				"\t\tB.append(B[-1] + a)",
				"\treturn B"],
		"description": "累積和"
	},

	"union find":{
		"prefix": "unionfind",
		"body":["class UnionFind():",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.parents = [-1] * n",		
				"\tdef find(self, x):",
				"\t\tif self.parents[x] < 0:",
				"\t\t\treturn x",
				"\t\telse:",
				"\t\t\tself.parents[x] = self.find(self.parents[x])",
				"\t\t\treturn self.parents[x]",
				"\tdef union(self, x, y):",
				"\t\tx = self.find(x)",
				"\t\ty = self.find(y)",
				"\t\tif x == y:",
				"\t\t\treturn",
				"\t\tif self.parents[x] > self.parents[y]:",
				"\t\t\tx, y = y, x",
				"\t\tself.parents[x] += self.parents[y]",
				"\t\tself.parents[y] = x",
				"\tdef size(self, x):",
				"\t\treturn -self.parents[self.find(x)]",
				"\tdef same(self, x, y):",
				"\t\treturn self.find(x) == self.find(y)",
				"\tdef members(self, x):",
				"\t\troot = self.find(x)",
				"\t\treturn [i for i in range(self.n) if self.find(i) == root]",
				"\tdef roots(self):",
				"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
				"\tdef group_count(self):",
				"\t\treturn len(self.roots())",
				"\tdef all_group_members(self):",
				"\t\treturn {r: self.members(r) for r in self.roots()}",
				"\tdef __str__(self):",
				"\t\treturn '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())"],
		"description": "unionfind"
	},

	"meguru_bisect":{
		"prefix": "megurubisect",
		"body":["def is_ok(arg):",
				"\t# 条件を満たすかどうか？問題ごとに定義",
				"\tpass",
				"",
				"",
				"def meguru_bisect(ng, ok):",
				"\t'''",
				"\t初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す",
				"\tまずis_okを定義すべし",
				"\tng ok は  とり得る最小の値-1 とり得る最大の値+1",
				"\t最大最小が逆の場合はよしなにひっくり返す",
				"\t'''",
				"\twhile (abs(ok - ng) > 1):",
				"\t\tmid = (ok + ng) // 2",
				"\t\tif is_ok(mid):",
				"\t\t\tok = mid",
				"\t\telse:",
				"\t\t\tng = mid",
				"\treturn ok"],
		"description": "めぐる式二分探索"
	}
}