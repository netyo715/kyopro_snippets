{
	"factorization":{
		"prefix": "soinsuubunkai",
		"body":["def factorization(n):",
				"\tarr = []",
				"\ttemp = n",
				"\tfor i in range(2, int(-(-n**0.5//1))+1):",
				"\t\tif temp%i==0:",
				"\t\t\tcnt=0",
				"\t\t\twhile temp%i==0:",
				"\t\t\t\tcnt+=1",
				"\t\t\t\ttemp //= i",
				"\t\t\tarr.append([i, cnt])",
				"\tif temp!=1:",
				"\t\tarr.append([temp, 1])",
				"\tif arr==[]:",
				"\t\tarr.append([n, 1])",
				"\treturn arr"],
		"description": "素因数分解"
	},

	"combination":{
		"prefix": "ncr",
		"body":["def cmb(n, r, mod):",
				"\tif (r < 0) or (n < r):",
				"\t\treturn 0",
				"\tr = min(r, n - r)",
				"\treturn fact[n] * factinv[r] * factinv[n-r] % mod",
				"",
				"mod = 10 ** 9 + 7",
				"N = 10 ** 6  # N は必要分だけ用意する",
				"fact = [1, 1]  # fact[n] = (n! mod mod)",
				"factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod mod)",
				"inv = [0, 1]  # factinv 計算用",
				" ",
				"for i in range(2, N + 1):",
				"\tfact.append((fact[-1] * i) % mod)",
				"\tinv.append((-inv[mod % i] * (mod // i)) % mod)",
				"\tfactinv.append((factinv[-1] * inv[-1]) % mod)"],
		"description": "nCr n個からr個選ぶ組み合わせmod mod"
	},

	"cumulative sum":{
		"prefix": "zalgo",
		"body":["def z(s):",
				"\tn = len(s)",
				"\tret = [0]*n",
				"\tret[0] = n",
				"\ti = 1",
				"\tj = 0",
				"\twhile i < n:",
				"\t\twhile i+j < n and s[j] == s[i+j]:",
				"\t\t\tj += 1",
				"\t\tret[i] = j",
				"\t\tif j == 0:",
				"\t\t\ti += 1",
				"\t\t\tcontinue",
				"\t\tk = 1",
				"\t\twhile i+k < n and k+ret[k] < j:",
				"\t\t\tret[i+k] = ret[k]",
				"\t\t\tk += 1",
				"\t\ti += k",
				"\t\tj -= k",
				"\treturn ret"],
		"description": "z-algorithm"
	},

	"union find":{
		"prefix": "unionfind",
		"body":["class UnionFind():",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.parents = [-1] * n",		
				"",
				"\tdef find(self, x):",
				"\t\tif self.parents[x] < 0:",
				"\t\t\treturn x",
				"\t\telse:",
				"\t\t\tself.parents[x] = self.find(self.parents[x])",
				"\t\t\treturn self.parents[x]",
				"",
				"\tdef union(self, x, y):",
				"\t\tx = self.find(x)",
				"\t\ty = self.find(y)",
				"\t\tif x == y:",
				"\t\t\treturn",
				"\t\tif self.parents[x] > self.parents[y]:",
				"\t\t\tx, y = y, x",
				"\t\tself.parents[x] += self.parents[y]",
				"\t\tself.parents[y] = x",
				"",
				"\tdef size(self, x):",
				"\t\treturn -self.parents[self.find(x)]",
				"",
				"\tdef same(self, x, y):",
				"\t\treturn self.find(x) == self.find(y)",
				"",
				"\tdef members(self, x):",
				"\t\troot = self.find(x)",
				"\t\treturn [i for i in range(self.n) if self.find(i) == root]",
				"",
				"\tdef roots(self):",
				"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
				"",
				"\tdef group_count(self):",
				"\t\treturn len(self.roots())",
				"",
				"\tdef all_group_members(self):",
				"\t\treturn {r: self.members(r) for r in self.roots()}",
				"",
				"\tdef __str__(self):",
				"\t\treturn '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())"],
		"description": "unionfind"
	},

	"meguru_bisect":{
		"prefix": "megurubisect",
		"body":["def is_ok(arg):",
				"\t# 条件を満たすかどうか？問題ごとに定義",
				"\tpass",
				"",
				"",
				"def meguru_bisect(ng, ok):",
				"\t'''",
				"\t初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す",
				"\tまずis_okを定義すべし",
				"\tng ok は  とり得る最小の値-1 とり得る最大の値+1",
				"\t最大最小が逆の場合はよしなにひっくり返す",
				"\t'''",
				"\twhile (abs(ok - ng) > 1):",
				"\t\tmid = (ok + ng) // 2",
				"\t\tif is_ok(mid):",
				"\t\t\tok = mid",
				"\t\telse:",
				"\t\t\tng = mid",
				"\treturn ok"],
		"description": "めぐる式二分探索"
	},

	"fenwicktree":{
		"prefix": "fenwicktree",
		"body":["class BIT:",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.data = [0]*(n+1)",
				"\t\tself.el = [0]*(n+1)",
				"",
				"\tdef sum(self, i):",
				"\t\ts = 0",
				"\t\twhile i > 0:",
				"\t\t\ts += self.data[i]",
				"\t\t\ti -= i & -i",
				"\t\treturn s",
				"",
				"\tdef add(self, i, x):",
				"\t\tself.el[i] += x",
				"\t\twhile i <= self.n:",
				"\t\t\tself.data[i] += x",
				"\t\t\ti += i & -i",
				"\t\t\t",
				"\tdef get(self, i, j=None):",
				"\t\tif j is None:",
				"\t\t\treturn self.el[i]",
				"\t\treturn self.sum(j) - self.sum(i)"],
		"description": "fenwick tree (BIT)"
	},

	"segment tree":{
		"prefix": "segtree",
		"body":["#####segfunc######",
				"def segfunc(x,y):",
				"\treturn ",
				"",
				"def init(init_val):",
				"\t#set_val",
				"\tfor i in range(N):",
				"\t\tseg[i+num-1]=init_val[i]\t",
				"\t#built",
				"\tfor i in range(num-2,-1,-1) :",
				"\t\tseg[i]=segfunc(seg[2*i+1],seg[2*i+2]) ",
				"\t",
				"def update(k,x):",
				"\tk += num-1",
				"\tseg[k] = x",
				"\twhile k:",
				"\t\tk = (k-1)//2",
				"\t\tseg[k] = segfunc(seg[k*2+1],seg[k*2+2])",
				"\t",
				"def query(p,q):",
				"\tif q<=p:",
				"\t\treturn ide_ele",
				"\tp += num-1",
				"\tq += num-2",
				"\tres=ide_ele",
				"\twhile q-p>1:",
				"\t\tif p&1 == 0:",
				"\t\t\tres = segfunc(res,seg[p])",
				"\t\tif q&1 == 1:",
				"\t\t\tres = segfunc(res,seg[q])",
				"\t\t\tq -= 1",
				"\t\tp = p//2",
				"\t\tq = (q-1)//2",
				"\tif p == q:",
				"\t\tres = segfunc(res,seg[p])",
				"\telse:",
				"\t\tres = segfunc(segfunc(res,seg[p]),seg[q])",
				"\treturn res",
				"",
				"#####単位元######",
				"#最小値のセグ木 → +inf",
				"#和のセグ木 → 0",
				"#積のセグ木 → 1",
				"#gcdのセグ木 → 0",
				"ide_ele = ",
				"",
				"#num:n以上の最小の2のべき乗",
				"num =2**(N-1).bit_length()",
				"seg=[ide_ele]*2*num"],
		"description": "セグメント木"
	}
}