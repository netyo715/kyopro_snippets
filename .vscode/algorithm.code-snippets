{
	"factorization":{//与えられた整数を素因数分解する
		"prefix": "soinsuubunkai",
		"body":["def factorization(n):",
				"\tarr = []",
				"\ttemp = n",
				"\tfor i in range(2, int(-(-n**0.5//1))+1):",
				"\t\tif temp%i==0:",
				"\t\t\tcnt=0",
				"\t\t\twhile temp%i==0:",
				"\t\t\t\tcnt+=1",
				"\t\t\t\ttemp //= i",
				"\t\t\tarr.append([i, cnt])",
				"\tif temp!=1:",
				"\t\tarr.append([temp, 1])",
				"\tif arr==[]:",
				"\t\tarr.append([n, 1])",
				"\treturn arr"],
		"description": "与えられた整数を素因数分解する"
	},

	"combination":{//前計算をしてnCrをmodで割ったあまりを求める
		"prefix": "ncr",
		"body":["cmbMOD = 10**9+7",
				"cmbN = 10**6",
				"cmbfact = [1, 1]  # fact[n] = (n! mod MOD)",
				"cmbfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod MOD)",
				"cmbinv = [0, 1]  # factinv 計算用",
				"",
				"for i in range(2, cmbN + 1):",
				"\tcmbfact.append((cmbfact[-1] * i) % cmbMOD)",
				"\tcmbinv.append((-cmbinv[cmbMOD % i] * (cmbMOD // i)) % cmbMOD)",
				"\tcmbfactinv.append((cmbfactinv[-1] * cmbinv[-1]) % cmbMOD)",
				"",
				"def cmb(n, r):",
				"\tif (r < 0) or (n < r):",
				"\t\treturn 0",
				"\tr = min(r, n - r)",
				"\treturn cmbfact[n] * cmbfactinv[r] * cmbfactinv[n-r] % cmbMOD"],
		"description": "nCr n個からr個選ぶ組み合わせmod MOD"
	},

	"cumulative sum":{//zアルゴリズム SとS[i:]の共通接頭辞の長さを全てのiについて求める
		"prefix": "zalgo",
		"body":["def z(s):",
				"\tn = len(s)",
				"\tret = [0]*n",
				"\tret[0] = n",
				"\ti = 1",
				"\tj = 0",
				"\twhile i < n:",
				"\t\twhile i+j < n and s[j] == s[i+j]:",
				"\t\t\tj += 1",
				"\t\tret[i] = j",
				"\t\tif j == 0:",
				"\t\t\ti += 1",
				"\t\t\tcontinue",
				"\t\tk = 1",
				"\t\twhile i+k < n and k+ret[k] < j:",
				"\t\t\tret[i+k] = ret[k]",
				"\t\t\tk += 1",
				"\t\ti += k",
				"\t\tj -= k",
				"\treturn ret"],
		"description": "z-algorithm"
	},

	"union find":{//unionfind木
		"prefix": "unionfind",
		"body":["class UnionFind():",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.parents = [-1] * n",		
				"",
				"\tdef find(self, x):",
				"\t\tif self.parents[x] < 0:",
				"\t\t\treturn x",
				"\t\telse:",
				"\t\t\tself.parents[x] = self.find(self.parents[x])",
				"\t\t\treturn self.parents[x]",
				"",
				"\tdef union(self, x, y):",
				"\t\tx = self.find(x)",
				"\t\ty = self.find(y)",
				"\t\tif x == y:",
				"\t\t\treturn",
				"\t\tif self.parents[x] > self.parents[y]:",
				"\t\t\tx, y = y, x",
				"\t\tself.parents[x] += self.parents[y]",
				"\t\tself.parents[y] = x",
				"",
				"\tdef size(self, x):",
				"\t\treturn -self.parents[self.find(x)]",
				"",
				"\tdef same(self, x, y):",
				"\t\treturn self.find(x) == self.find(y)",
				"",
				"\tdef members(self, x):",
				"\t\troot = self.find(x)",
				"\t\treturn [i for i in range(self.n) if self.find(i) == root]",
				"",
				"\tdef roots(self):",
				"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
				"",
				"\tdef group_count(self):",
				"\t\treturn len(self.roots())",
				"",
				"\tdef all_group_members(self):",
				"\t\treturn {r: self.members(r) for r in self.roots()}",
				"",
				"\tdef __str__(self):",
				"\t\treturn '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())"],
		"description": "unionfind"
	},

	"meguru_bisect":{//二分探索
		"prefix": "megurubisect",
		"body":["def is_ok(arg):",
				"\tpass",
				"",
				"",
				"def meguru_bisect(ng, ok):",
				"\twhile (abs(ok - ng) > 1):",
				"\t\tmid = (ok + ng) // 2",
				"\t\tif is_ok(mid):",
				"\t\t\tok = mid",
				"\t\telse:",
				"\t\t\tng = mid",
				"\treturn ok"],
		"description": "めぐる式二分探索"
	},

	"fenwicktree":{//fenwicktree/BIT 区間の総和がとれるやつ
		"prefix": "fenwicktree",
		"body":["class BIT:",
				"\tdef __init__(self, n):",
				"\t\tself.n = n",
				"\t\tself.data = [0]*(n+1)",
				"\t\tself.el = [0]*(n+1)",
				"",
				"\tdef sum(self, i):",
				"\t\ts = 0",
				"\t\twhile i > 0:",
				"\t\t\ts += self.data[i]",
				"\t\t\ti -= i & -i",
				"\t\treturn s",
				"",
				"\tdef add(self, i, x):",
				"\t\tself.el[i] += x",
				"\t\twhile i <= self.n:",
				"\t\t\tself.data[i] += x",
				"\t\t\ti += i & -i",
				"\t\t\t",
				"\tdef get(self, i, j=None):",
				"\t\tif j is None:",
				"\t\t\treturn self.el[i]",
				"\t\treturn self.sum(j) - self.sum(i)"],
		"description": "fenwick tree (BIT)"
	},

	"segment tree":{//セグ木
		"prefix": "segtree",
		"body":["class SegTree:",
				"\tdef __init__(self, N, A, ide_ele):",
				"\t\tself.N = N",
				"\t\t#####単位元######",
				"\t\t#最小値のセグ木 → +inf",
				"\t\t#和のセグ木 → 0",
				"\t\t#積のセグ木 → 1",
				"\t\t#gcdのセグ木 → 0",
				"\t\tself.ide_ele = ide_ele",
				"",
				"\t\t#num:n以上の最小の2のべき乗",
				"\t\tself.num =2**(self.N-1).bit_length()",
				"\t\tself.seg=[self.ide_ele]*2*self.num",
				"",
				"\t\tself.init(A)",
				"",
				"\t#####segfunc######",
				"\tdef segfunc(self, x,y):",
				"\t\treturn ",
				"",
				"\tdef init(self, init_val):",
				"\t\t#set_val",
				"\t\tfor i in range(self.N):",
				"\t\t\tself.seg[i+self.num-1]=init_val[i]       ",
				"\t\t#built",
				"\t\tfor i in range(self.num-2,-1,-1) :",
				"\t\t\tself.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) ",
				"\t\t",
				"\tdef update(self, k,x):",
				"\t\tk += self.num-1",
				"\t\tself.seg[k] = x",
				"\t\twhile k:",
				"\t\t\tk = (k-1)//2",
				"\t\t\tself.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])",
				"\t\t",
				"\tdef query(self, p,q):",
				"\t\tif q<=p:",
				"\t\t\treturn self.ide_ele",
				"\t\tp += self.num-1",
				"\t\tq += self.num-2",
				"\t\tres=self.ide_ele",
				"\t\twhile q-p>1:",
				"\t\t\tif p&1 == 0:",
				"\t\t\t\tres = self.segfunc(res,self.seg[p])",
				"\t\t\tif q&1 == 1:",
				"\t\t\t\tres = self.segfunc(res,self.seg[q])",
				"\t\t\t\tq -= 1",
				"\t\t\tp = p//2",
				"\t\t\tq = (q-1)//2",
				"\t\tif p == q:",
				"\t\t\tres = self.segfunc(res,self.seg[p])",
				"\t\telse:",
				"\t\t\tres = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])",
				"\t\treturn res"],
		"description": "セグメント木"
	},
	
	"modinv": {//a mod m aの逆元を求める
		"prefix": "gyakugen",
		"body":["def xgcd(a, b):",
				"\tx0, y0, x1, y1 = 1, 0, 0, 1",
				"\twhile b != 0:",
				"\t\tq, a, b = a // b, b, a % b",
				"\t\tx0, x1 = x1, x0 - q * x1",
				"\t\ty0, y1 = y1, y0 - q * y1",
				"\treturn a, x0, y0",
				"",
				"def modinv(a, m):",
				"\tg, x, y = xgcd(a, m)",
				"\tif g != 1:",
				"\t\traise Exception('modular inverse does not exist')",
				"\telse:",
				"\t\treturn x % m"],
		"description": "aの逆元を求める"
	},

	"EularTour":{
		"prefix": "eulartour",
		"body":["def EulerTour(N, G, start):",
				"\timport sys",
				"\tsys.setrecursionlimit(10**6)",
				"\tin_time = [0]*N",
				"\tout_time = [0]*N",
				"",
				"\tdef dfs(prev, now, time):",
				"\t\tin_time[now] = time",
				"\t\ttime += 1",
				"\t\tfor next in G[now]:",
				"\t\t\tif next==prev:",
				"\t\t\t\tcontinue",
				"\t\t\ttime = dfs(now, next, time)",
				"\t\tout_time[now] = time",
				"\t\ttime += 1",
				"\t\treturn time",
				"",
				"\tdfs(-1, start, 0)",
				"",
				"\treturn in_time, out_time",],
		"description": "オイラーツアー"
	},

	"sorted set":{
		"prefix": "sset",
		"body":["import math",
				"from bisect import bisect_left, bisect_right",
				"from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
				"T = TypeVar('T')",
				"",
				"class SortedSet(Generic[T]):",
				"\tBUCKET_RATIO = 50",
				"\tREBUILD_RATIO = 170",
				"",
				"\tdef _build(self, a=None) -> None:",
				"\t\t'Evenly divide `a` into buckets.'",
				"\t\tif a is None: a = list(self)",
				"\t\tsize = self.size = len(a)",
				"\t\tbucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
				"\t\tself.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
				"\t",
				"\tdef __init__(self, a: Iterable[T] = []) -> None:",
				"\t\t'Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)'",
				"\t\ta = list(a)",
				"\t\tif not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
				"\t\t\ta = sorted(set(a))",
				"\t\tself._build(a)",
				"",
				"\tdef __iter__(self) -> Iterator[T]:",
				"\t\tfor i in self.a:",
				"\t\t\tfor j in i: yield j",
				"",
				"\tdef __reversed__(self) -> Iterator[T]:",
				"\t\tfor i in reversed(self.a):",
				"\t\t\tfor j in reversed(i): yield j",
				"\t",
				"\tdef __len__(self) -> int:",
				"\t\treturn self.size",
				"\t",
				"\tdef __repr__(self) -> str:",
				"\t\treturn 'SortedSet' + str(self.a)",
				"\t",
				"\tdef __str__(self) -> str:",
				"\t\ts = str(list(self))",
				"\t\treturn '{' + s[1 : len(s) - 1] + '}'",
				"",
				"\tdef _find_bucket(self, x: T) -> List[T]:",
				"\t\t'Find the bucket which should contain x. self must not be empty.'",
				"\t\tfor a in self.a:",
				"\t\t\tif x <= a[-1]: return a",
				"\t\treturn a",
				"",
				"\tdef __contains__(self, x: T) -> bool:",
				"\t\tif self.size == 0: return False",
				"\t\ta = self._find_bucket(x)",
				"\t\ti = bisect_left(a, x)",
				"\t\treturn i != len(a) and a[i] == x",
				"",
				"\tdef add(self, x: T) -> bool:",
				"\t\t'Add an element and return True if added. / O(��N)'",
				"\t\tif self.size == 0:",
				"\t\t\tself.a = [[x]]",
				"\t\t\tself.size = 1",
				"\t\t\treturn True",
				"\t\ta = self._find_bucket(x)",
				"\t\ti = bisect_left(a, x)",
				"\t\tif i != len(a) and a[i] == x: return False",
				"\t\ta.insert(i, x)",
				"\t\tself.size += 1",
				"\t\tif len(a) > len(self.a) * self.REBUILD_RATIO:",
				"\t\t\tself._build()",
				"\t\treturn True",
				"",
				"\tdef discard(self, x: T) -> bool:",
				"\t\t'Remove an element and return True if removed. / O(��N)'",
				"\t\tif self.size == 0: return False",
				"\t\ta = self._find_bucket(x)",
				"\t\ti = bisect_left(a, x)",
				"\t\tif i == len(a) or a[i] != x: return False",
				"\t\ta.pop(i)",
				"\t\tself.size -= 1",
				"\t\tif len(a) == 0: self._build()",
				"\t\treturn True",
				"\t",
				"\tdef lt(self, x: T) -> Union[T, None]:",
				"\t\t'Find the largest element < x, or None if it doesnt exist.'",
				"\t\tfor a in reversed(self.a):",
				"\t\t\tif a[0] < x:",
				"\t\t\t\treturn a[bisect_left(a, x) - 1]",
				"",
				"\tdef le(self, x: T) -> Union[T, None]:",
				"\t\t'Find the largest element <= x, or None if it doesnt exist.'",
				"\t\tfor a in reversed(self.a):",
				"\t\t\tif a[0] <= x:",
				"\t\t\t\treturn a[bisect_right(a, x) - 1]",
				"",
				"\tdef gt(self, x: T) -> Union[T, None]:",
				"\t\t'Find the smallest element > x, or None if it doesnt exist.'",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] > x:",
				"\t\t\t\treturn a[bisect_right(a, x)]",
				"",
				"\tdef ge(self, x: T) -> Union[T, None]:",
				"\t\t'Find the smallest element >= x, or None if it doesnt exist.'",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] >= x:",
				"\t\t\t\treturn a[bisect_left(a, x)]",
				"\t",
				"\tdef __getitem__(self, x: int) -> T:",
				"\t\t'Return the x-th element, or IndexError if it doesnt exist.'",
				"\t\tif x < 0: x += self.size",
				"\t\tif x < 0: raise IndexError",
				"\t\tfor a in self.a:",
				"\t\t\tif x < len(a): return a[x]",
				"\t\t\tx -= len(a)",
				"\t\traise IndexError",
				"\t",
				"\tdef index(self, x: T) -> int:",
				"\t\t'Count the number of elements < x.'",
				"\t\tans = 0",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] >= x:",
				"\t\t\t\treturn ans + bisect_left(a, x)",
				"\t\t\tans += len(a)",
				"\t\treturn ans",
				"",
				"\tdef index_right(self, x: T) -> int:",
				"\t\t'Count the number of elements <= x.'",
				"\t\tans = 0",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] > x:",
				"\t\t\t\treturn ans + bisect_right(a, x)",
				"\t\t\tans += len(a)",
				"\t\treturn ans",],
		"description": "sorted set"
	},

	"sorted multiset":{
		"prefix": "smset",
		"body":["import math",
				"from bisect import bisect_left, bisect_right, insort",
				"from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
				"T = TypeVar('T')",
				"",
				"class SortedMultiset(Generic[T]):",
				"\tBUCKET_RATIO = 50",
				"\tREBUILD_RATIO = 170",
				"",
				"\tdef _build(self, a=None) -> None:",
				"\t\t'Evenly divide `a` into buckets.'",
				"\t\tif a is None: a = list(self)",
				"\t\tsize = self.size = len(a)",
				"\t\tbucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
				"\t\tself.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
				"\t",
				"\tdef __init__(self, a: Iterable[T] = []) -> None:",
				"\t\t'Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)'",
				"\t\ta = list(a)",
				"\t\tif not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
				"\t\t\ta = sorted(a)",
				"\t\tself._build(a)",
				"",
				"\tdef __iter__(self) -> Iterator[T]:",
				"\t\tfor i in self.a:",
				"\t\t\tfor j in i: yield j",
				"",
				"\tdef __reversed__(self) -> Iterator[T]:",
				"\t\tfor i in reversed(self.a):",
				"\t\t\tfor j in reversed(i): yield j",
				"\t",
				"\tdef __len__(self) -> int:",
				"\t\treturn self.size",
				"\t",
				"\tdef __repr__(self) -> str:",
				"\t\treturn 'SortedMultiset' + str(self.a)",
				"\t",
				"\tdef __str__(self) -> str:",
				"\t\ts = str(list(self))",
				"\t\treturn '{' + s[1 : len(s) - 1] + '}'",
				"",
				"\tdef _find_bucket(self, x: T) -> List[T]:",
				"\t\t'Find the bucket which should contain x. self must not be empty.'",
				"\t\tfor a in self.a:",
				"\t\t\tif x <= a[-1]: return a",
				"\t\treturn a",
				"",
				"\tdef __contains__(self, x: T) -> bool:",
				"\t\tif self.size == 0: return False",
				"\t\ta = self._find_bucket(x)",
				"\t\ti = bisect_left(a, x)",
				"\t\treturn i != len(a) and a[i] == x",
				"",
				"\tdef count(self, x: T) -> int:",
				"\t\t'Count the number of x.'",
				"\t\treturn self.index_right(x) - self.index(x)",
				"",
				"\tdef add(self, x: T) -> None:",
				"\t\t'Add an element. / O(��N)'",
				"\t\tif self.size == 0:",
				"\t\t\tself.a = [[x]]",
				"\t\t\tself.size = 1",
				"\t\t\treturn",
				"\t\ta = self._find_bucket(x)",
				"\t\tinsort(a, x)",
				"\t\tself.size += 1",
				"\t\tif len(a) > len(self.a) * self.REBUILD_RATIO:",
				"\t\t\tself._build()",
				"",
				"\tdef discard(self, x: T) -> bool:",
				"\t\t'Remove an element and return True if removed. / O(��N)'",
				"\t\tif self.size == 0: return False",
				"\t\ta = self._find_bucket(x)",
				"\t\ti = bisect_left(a, x)",
				"\t\tif i == len(a) or a[i] != x: return False",
				"\t\ta.pop(i)",
				"\t\tself.size -= 1",
				"\t\tif len(a) == 0: self._build()",
				"\t\treturn True",
				"",
				"\tdef lt(self, x: T) -> Union[T, None]:",
				"\t\t'Find the largest element < x, or None if it doesnt exist.'",
				"\t\tfor a in reversed(self.a):",
				"\t\t\tif a[0] < x:",
				"\t\t\t\treturn a[bisect_left(a, x) - 1]",
				"",
				"\tdef le(self, x: T) -> Union[T, None]:",
				"\t\t'Find the largest element <= x, or None if it doesnt exist.'",
				"\t\tfor a in reversed(self.a):",
				"\t\t\tif a[0] <= x:",
				"\t\t\t\treturn a[bisect_right(a, x) - 1]",
				"",
				"\tdef gt(self, x: T) -> Union[T, None]:",
				"\t\t'Find the smallest element > x, or None if it doesnt exist.'",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] > x:",
				"\t\t\t\treturn a[bisect_right(a, x)]",
				"",
				"\tdef ge(self, x: T) -> Union[T, None]:",
				"\t\t'Find the smallest element >= x, or None if it doesnt exist.'",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] >= x:",
				"\t\t\t\treturn a[bisect_left(a, x)]",
				"\t",
				"\tdef __getitem__(self, x: int) -> T:",
				"\t\t'Return the x-th element, or IndexError if it doesnt exist.'",
				"\t\tif x < 0: x += self.size",
				"\t\tif x < 0: raise IndexError",
				"\t\tfor a in self.a:",
				"\t\t\tif x < len(a): return a[x]",
				"\t\t\tx -= len(a)",
				"\t\traise IndexError",
				"",
				"\tdef index(self, x: T) -> int:",
				"\t\t'Count the number of elements < x.'",
				"\t\tans = 0",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] >= x:",
				"\t\t\t\treturn ans + bisect_left(a, x)",
				"\t\t\tans += len(a)",
				"\t\treturn ans",
				"",
				"\tdef index_right(self, x: T) -> int:",
				"\t\t'Count the number of elements <= x.'",
				"\t\tans = 0",
				"\t\tfor a in self.a:",
				"\t\t\tif a[-1] > x:",
				"\t\t\t\treturn ans + bisect_right(a, x)",
				"\t\t\tans += len(a)",
				"\t\treturn ans",],
		"description": ""
	},
	"ModInt":{
		"prefix": "mint",
		"body":["class ModInt:",
				"\tdef __init__(self, x):",
				"\t\tself.x = x % MOD",
				"",
				"\tdef __str__(self):",
				"\t\treturn str(self.x)",
				"",
				"\t__repr__ = __str__",
				"",
				"\tdef __add__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(self.x + other.x) if isinstance(other, ModInt) else",
				"\t\t\tModInt(self.x + other)",
				"\t\t)",
				"",
				"\tdef __sub__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(self.x - other.x) if isinstance(other, ModInt) else",
				"\t\t\tModInt(self.x - other)",
				"\t\t)",
				"",
				"\tdef __mul__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(self.x * other.x) if isinstance(other, ModInt) else",
				"\t\t\tModInt(self.x * other)",
				"\t\t)",
				"",
				"\tdef __truediv__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(",
				"\t\t\t\tself.x * pow(other.x, MOD - 2, MOD)",
				"\t\t\t) if isinstance(other, ModInt) else",
				"\t\t\tModInt(self.x * pow(other, MOD - 2, MOD))",
				"\t\t)",
				"",
				"\tdef __pow__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else",
				"\t\t\tModInt(pow(self.x, other, MOD))",
				"\t\t)",
				"",
				"\t__radd__ = __add__",
				"",
				"\tdef __rsub__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(other.x - self.x) if isinstance(other, ModInt) else",
				"\t\t\tModInt(other - self.x)",
				"\t\t)",
				"",
				"\t__rmul__ = __mul__",
				"",
				"\tdef __rtruediv__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(",
				"\t\t\t\tother.x * pow(self.x, MOD - 2, MOD)",
				"\t\t\t) if isinstance(other, ModInt) else",
				"\t\t\tModInt(other * pow(self.x, MOD - 2, MOD))",
				"\t\t)",
				"",
				"\tdef __rpow__(self, other):",
				"\t\treturn (",
				"\t\t\tModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt) else",
				"\t\t\tModInt(pow(other, self.x, MOD))",
				"\t\t)",],
		"description": "ModInt"
	},	
}